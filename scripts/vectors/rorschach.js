// Title: Rorschach
// Author: FAL
// Date: 18. Nov. 2017
// Made with p5.js v0.5.16
// Generated by TypeScript v2.6.1

/*
  LICENCE:
    The font "Bellefair-Regular.ttf" ( https://github.com/shinntype/bellefair ) is
    licensed under the SIL Open Font License, Version 1.1 ( http://scripts.sil.org/OFL ).
*/


"use strict";


// ------------ Rorschach shape ------------------------------
//
/// <reference path="../../../my_types/p5/p5.global-mode.d.ts" />
/// <reference path="Sprite.ts" />

const fontPath = '../../assets/fonts/Bellefair-Regular.ttf';
const IDEAL_FRAME_RATE = 60;


class RorschachShape {
    constructor(params, palette) {
        this.shapeSize = params.shapeSize;
        this.noiseMagnitudeFactor = params.noiseMagnitudeFactor;
        this.centerPosition = createVector(width/2, height/2);
        this.rotationAngle = PI + HALF_PI;
        this.vertexCount = params.vertexCount || Math.floor(0.75 * params.shapeSize);
        this.noiseDistanceScale = params.noiseDistanceScale || params.shapeSize / 320;
        this.noiseTimeScale = params.noiseTimeScale || 0.005;
        this.xNoiseParameterOffset
            = createVector(Math.random(), Math.random()).mult(1024);
        this.yNoiseParameterOffset
            = createVector(Math.random(), Math.random()).mult(1024);
        this.noiseTime = 0;
        this.reachedEndOfScreen = false;
        if (RorschachShape.isNotInitialized)
            RorschachShape.initializeStatic();
        this.frameCounter;
        this.palette = palette
    }
    static initializeStatic() {
        this.temporalVector = createVector();
        this.isNotInitialized = false;
    }
    setup(){
      var unitLength = Math.min(width, height) / 640;
      var currentFont = loadFont(fontPath);
      var currentFontSize =  14 * unitLength;
      var unitSpeed = this.unitLength / frameRate; // not sure if this is valid
      textFont(currentFont, currentFontSize);
      FrameCounter.initializeStatic(IDEAL_FRAME_RATE);
      this.frameCounter =  new TimedFrameCounter(true, 13 * IDEAL_FRAME_RATE, () => { noLoop(); });
      // noFill();

    }

    step() {
        this.noiseTime += this.noiseTimeScale;
    }
    display() {
        // if (this.reachedEndOfScreen)
        //     return;
        translate(this.centerPosition.x, this.centerPosition.y);
        rotate(this.rotationAngle);
        for(var i = -1; i< 1; i += 0.1){
          this.drawVertices(i);
        }
        // this.drawVertices(+2);
        // this.drawVertices(+1);
        // this.drawVertices(-1);

        rotate(-this.rotationAngle);
        translate(-this.centerPosition.x, -this.centerPosition.y);
        this.step();
        this.frameCounter.step();
    }
    drawVertices(yScaleFactor) {
        const noiseMagnitude = this.noiseMagnitudeFactor * 1.5 * this.shapeSize;
        var palCol = this.palette[0]
        var palCol1 = this.palette[1]

        fill(palCol[0],palCol[1],palCol[2], 30)
        stroke(255,255,255, 30)

        beginShape();
        let currentBasePositionX = -0.5 * this.shapeSize;
        const basePositionIntervalDistance = this.shapeSize / this.vertexCount;
        const progressRatio = this.frameCounter.getProgressRatio();
        for (let i = 0; i < this.vertexCount; i += 1) {
            const distanceFactor = progressRatio * sq(sin((i / this.vertexCount) * PI));
            const noiseX = (2 * noise(this.xNoiseParameterOffset.x + this.noiseDistanceScale * currentBasePositionX, this.xNoiseParameterOffset.y + this.noiseTime) - 1) * noiseMagnitude;
            const noiseY = (2 * noise(this.yNoiseParameterOffset.x + this.noiseDistanceScale * currentBasePositionX, this.yNoiseParameterOffset.y + this.noiseTime) - 1) * noiseMagnitude;
            const vertexPositionX = currentBasePositionX + distanceFactor * noiseX;
            const vertexPositionY = yScaleFactor * distanceFactor * (0.3 * this.shapeSize + noiseY);

            vertex(vertexPositionX, vertexPositionY);
            const rotatedVertexPosition = RorschachShape.temporalVector;
            rotatedVertexPosition.set(vertexPositionX, vertexPositionY);
            rotatedVertexPosition.rotate(this.rotationAngle);
            this.checkScreen(this.centerPosition.x + rotatedVertexPosition.x, this.centerPosition.y + rotatedVertexPosition.y);
            currentBasePositionX += basePositionIntervalDistance;
        }
        endShape();
    }
    checkScreen(absolutePositionX, absolutePositionY) {
        const xMargin = 0.01 * width;
        const yMargin = 0.05 * height;
        if (absolutePositionX < xMargin || absolutePositionX > width - xMargin ||
            absolutePositionY < yMargin || absolutePositionY > height - yMargin) {
            this.reachedEndOfScreen = true;
        }
    }
}
RorschachShape.isNotInitialized = true;

//
/// <reference path="../../../my_types/p5/p5.global-mode.d.ts" />
/// <reference path="ShapeColor.ts" />

/// <reference path="common/RorschachShape.ts" />
/// <reference path="common/ShapeColor.ts" />
/// <reference path="common/Sprite.ts" />
/// <reference path="common/FrameCounter.ts" />
/// <reference path="common/SignatureFunction.ts" />
//
