// https://github.com/d3/d3-delaunay Version 3.0.0. Copyright 2018 Observable, Inc.
// https://github.com/mapbox/delaunator Version 2.0.0. Copyright 2017, Mapbox, Inc.
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e(t.d3=t.d3||{})}(this,function(t){"use strict";function e(t){if(!ArrayBuffer.isView(t))throw new Error("Expected coords to be a typed array.");var e=1/0,a=1/0,c=-1/0,u=-1/0,f=t.length>>1,x=this.ids=new Uint32Array(f);this.coords=t;for(var _=0;_<f;_++){var d=t[2*_],g=t[2*_+1];d<e&&(e=d),g<a&&(a=g),d>c&&(c=d),g>u&&(u=g),x[_]=_}var m,y,v,p=(e+c)/2,w=(a+u)/2,b=1/0;for(_=0;_<f;_++){var T=i(p,w,t[2*_],t[2*_+1]);T<b&&(m=_,b=T)}for(b=1/0,_=0;_<f;_++)_!==m&&(T=i(t[2*m],t[2*m+1],t[2*_],t[2*_+1]))<b&&T>0&&(y=_,b=T);var $=1/0;for(_=0;_<f;_++)if(_!==m&&_!==y){var k=s(t[2*m],t[2*m+1],t[2*y],t[2*y+1],t[2*_],t[2*_+1]);k<$&&(v=_,$=k)}if($===1/0)throw new Error("No Delaunay triangulation exists for this input.");if(n(t[2*m],t[2*m+1],t[2*y],t[2*y+1],t[2*v],t[2*v+1])<0){var M=y;y=v,v=M}var A=t[2*m],E=t[2*m+1],S=t[2*y],z=t[2*y+1],F=t[2*v],L=t[2*v+1],j=function(t,e,i,n,s,r){var h=(i-=t)*i+(n-=e)*n,l=(s-=t)*s+(r-=e)*r,o=i*r-n*s;return{x:t+.5*(r*h-n*l)/o,y:e+.5*(i*l-s*h)/o}}(A,E,S,z,F,L);for(this._cx=j.x,this._cy=j.y,function t(e,i,n,s,r,h){var a,c,u;if(s-n<=20)for(a=n+1;a<=s;a++){for(u=e[a],c=a-1;c>=n&&l(i,e[c],u,r,h)>0;)e[c+1]=e[c--];e[c+1]=u}else{var f=n+s>>1;for(c=s,o(e,f,a=n+1),l(i,e[n],e[s],r,h)>0&&o(e,n,s),l(i,e[a],e[s],r,h)>0&&o(e,a,s),l(i,e[n],e[a],r,h)>0&&o(e,n,a),u=e[a];;){do{a++}while(l(i,e[a],u,r,h)<0);do{c--}while(l(i,e[c],u,r,h)>0);if(c<a)break;o(e,a,c)}e[n+1]=e[c],e[c]=u,s-a+1>=c-n?(t(e,i,a,s,r,h),t(e,i,n,c-1,r,h)):(t(e,i,n,c-1,r,h),t(e,i,a,s,r,h))}}(x,t,0,x.length-1,j.x,j.y),this._hashSize=Math.ceil(Math.sqrt(f)),this._hash=[],_=0;_<this._hashSize;_++)this._hash[_]=null;var P=this.hull=r(t,m);this._hashEdge(P),P.t=0,P=r(t,y,P),this._hashEdge(P),P.t=1,P=r(t,v,P),this._hashEdge(P),P.t=2;var U,I,K=2*f-5,B=this.triangles=new Uint32Array(3*K),D=this.halfedges=new Int32Array(3*K);this.trianglesLen=0,this._addTriangle(m,y,v,-1,-1,-1);for(var H=0;H<x.length;H++)if(d=t[2*(_=x[H])],g=t[2*_+1],!(d===U&&g===I||(U=d,I=g,d===A&&g===E||d===S&&g===z||d===F&&g===L))){var V,Z=this._hashKey(d,g),q=Z;do{V=this._hash[q],q=(q+1)%this._hashSize}while((!V||V.removed)&&q!==Z);for(P=V;n(d,g,P.x,P.y,P.next.x,P.next.y)>=0;)if((P=P.next)===V)throw new Error("Something is wrong with the input points.");var C=P===V,N=this._addTriangle(P.i,_,P.next.i,-1,-1,P.t);P.t=N,(P=r(t,_,P)).t=this._legalize(N+2),P.prev.prev.t===D[N+1]&&(P.prev.prev.t=N+2);for(var O=P.next;n(d,g,O.x,O.y,O.next.x,O.next.y)<0;)N=this._addTriangle(O.i,_,O.next.i,O.prev.t,-1,O.t),O.prev.t=this._legalize(N+2),this.hull=h(O),O=O.next;if(C)for(O=P.prev;n(d,g,O.prev.x,O.prev.y,O.x,O.y)<0;)N=this._addTriangle(O.prev.i,_,O.i,-1,O.t,O.prev.t),this._legalize(N+2),O.prev.t=N,this.hull=h(O),O=O.prev;this._hashEdge(P),this._hashEdge(P.prev)}this.triangles=B.subarray(0,this.trianglesLen),this.halfedges=D.subarray(0,this.trianglesLen)}function i(t,e,i,n){var s=t-i,r=e-n;return s*s+r*r}function n(t,e,i,n,s,r){return(n-e)*(s-i)-(i-t)*(r-n)}function s(t,e,i,n,s,r){var h=(i-=t)*i+(n-=e)*n,l=(s-=t)*s+(r-=e)*r;if(0===h||0===l)return 1/0;var o=i*r-n*s;if(0===o)return 1/0;var a=.5*(r*h-n*l)/o,c=.5*(i*l-s*h)/o;return a*a+c*c}function r(t,e,i){var n={i:e,x:t[2*e],y:t[2*e+1],t:0,prev:null,next:null,removed:!1};return i?(n.next=i.next,n.prev=i,i.next.prev=n,i.next=n):(n.prev=n,n.next=n),n}function h(t){return t.prev.next=t.next,t.next.prev=t.prev,t.removed=!0,t.prev}function l(t,e,n,s,r){return i(t[2*e],t[2*e+1],s,r)-i(t[2*n],t[2*n+1],s,r)||t[2*e]-t[2*n]||t[2*e+1]-t[2*n+1]}function o(t,e,i){var n=t[e];t[e]=t[i],t[i]=n}function a(t){return t[0]}function c(t){return t[1]}e.from=function(t,i,n){i||(i=a),n||(n=c);for(var s=t.length,r=new Float64Array(2*s),h=0;h<s;h++){var l=t[h];r[2*h]=i(l),r[2*h+1]=n(l)}return new e(r)},e.prototype={_hashEdge:function(t){this._hash[this._hashKey(t.x,t.y)]=t},_hashKey:function(t,e){var i=t-this._cx,n=e-this._cy,s=1-i/(Math.abs(i)+Math.abs(n));return Math.floor((2+(n<0?-s:s))/4*this._hashSize)},_legalize:function(t){var e,i,n,s,r,h,l,o,a,c,u=this.triangles,f=this.coords,x=this.halfedges,_=x[t],d=t-t%3,g=_-_%3,m=d+(t+1)%3,y=d+(t+2)%3,v=g+(_+2)%3,p=u[y],w=u[t],b=u[m],T=u[v];if(e=f[2*p],i=f[2*p+1],n=f[2*w],s=f[2*w+1],r=f[2*b],h=f[2*b+1],l=f[2*T],o=f[2*T+1],a=(n-=l)*n+(s-=o)*s,c=(r-=l)*r+(h-=o)*h,(e-=l)*(s*c-a*h)-(i-=o)*(n*c-a*r)+(e*e+i*i)*(n*h-s*r)<0){u[t]=T,u[_]=p,this._link(t,x[v]),this._link(_,x[y]),this._link(y,v);var $=g+(_+1)%3;return this._legalize(t),this._legalize($)}return y},_link:function(t,e){this.halfedges[t]=e,-1!==e&&(this.halfedges[e]=t)},_addTriangle:function(t,e,i,n,s,r){var h=this.trianglesLen;return this.triangles[h]=t,this.triangles[h+1]=e,this.triangles[h+2]=i,this._link(h,n),this._link(h+1,s),this._link(h+2,r),this.trianglesLen+=3,h}};class u{constructor(){this._x0=this._y0=this._x1=this._y1=null,this._=""}moveTo(t,e){this._+=`M${this._x0=this._x1=+t},${this._y0=this._y1=+e}`}closePath(){null!==this._x1&&(this._x1=this._x0,this._y1=this._y0,this._+="Z")}lineTo(t,e){this._+=`L${this._x1=+t},${this._y1=+e}`}arc(t,e,i){const n=(t=+t)+(i=+i),s=e=+e;if(i<0)throw new Error("negative radius");null===this._x1?this._+=`M${n},${s}`:(Math.abs(this._x1-n)>epsilon||Math.abs(this._y1-s)>epsilon)&&(this._+="L"+n+","+s),i&&(this._+=`A${i},${i},0,1,1,${t-i},${e}A${i},${i},0,1,1,${this._x1=n},${this._y1=s}`)}rect(t,e,i,n){this._+=`M${this._x0=this._x1=+t},${this._y0=this._y1=+e}h${+i}v${+n}h${-i}Z`}value(){return this._||null}}class f{constructor(t,[e,i,n,s]=[0,0,960,500]){if(!((n=+n)>=(e=+e)&&(s=+s)>=(i=+i)))throw new Error("invalid bounds");const{points:r,halfedges:h,hull:l,triangles:o}=this.delaunay=t,a=this.circumcenters=new Float64Array(o.length/3*2),c=this.edges=new Uint32Array(h.length),u=this.index=new Uint32Array(r.length),f=this.vectors=new Float64Array(2*r.length);this.xmax=n,this.xmin=e,this.ymax=s,this.ymin=i;for(let t=0,e=0,i=h.length;t<i;++t){const i=o[t];if(u[2*i]!==u[2*i+1])continue;const n=u[2*i]=e;let s=t;do{if(c[e++]=Math.floor(s/3),-1===(s=h[s]))break;if(o[s=s%3==2?s-2:s+1]!==i)break}while(s!==t);if(s!==t){const r=e;for(s=t;-1!==(s=h[s%3==0?s+2:s-1])&&o[s]===i;)c[e++]=Math.floor(s/3);r<e&&(c.subarray(n,r).reverse(),c.subarray(n,e).reverse())}u[2*i+1]=e}for(let t=0,e=0,i=o.length;t<i;t+=3,e+=2){const i=2*o[t],n=2*o[t+1],s=2*o[t+2],h=r[i],l=r[i+1],c=r[n],u=r[n+1],f=r[s],x=r[s+1],_=h-c,d=h-f,g=l-u,m=l-x,y=h*h+l*l,v=y-c*c-u*u,p=y-f*f-x*x,w=2*(d*g-_*m);a[e]=(g*p-m*v)/w,a[e+1]=(d*v-_*p)/w}for(let t,e,i,n=l.length,s=2*o[l[n-1]],h=r[s],a=r[s+1],c=0;c<n;++c)t=s,e=h,i=a,h=r[s=2*o[l[c]]],a=r[s+1],f[2*t+2]=f[2*s]=i-a,f[2*t+3]=f[2*s+1]=h-e}render(t){const e=null==t?t=new u:void 0,{delaunay:{halfedges:i,hull:n,triangles:s},circumcenters:r,vectors:h}=this;for(let e=0,n=i.length;e<n;++e){const n=i[e];if(n<e)continue;const s=2*Math.floor(e/3),h=2*Math.floor(n/3),l=r[s],o=r[s+1],a=r[h],c=r[h+1];this._renderSegment(l,o,a,c,t)}for(let e=0,i=n.length;e<i;++e){const i=2*Math.floor(n[e]/3),l=r[i],o=r[i+1],a=4*s[n[e]],c=this._project(l,o,h[a+2],h[a+3]);c&&this._renderSegment(l,o,c[0],c[1],t)}return e&&e.value()}renderBounds(t){const e=null==t?t=new u:void 0;return t.rect(this.xmin,this.ymin,this.xmax-this.xmin,this.ymax-this.ymin),e&&e.value()}renderCell(t,e){const i=null==e?e=new u:void 0,n=this._clip(t);if(null!==n){e.moveTo(n[0],n[1]);for(let t=2,i=n.length;t<i;t+=2)e.lineTo(n[t],n[t+1]);return e.closePath(),i&&i.value()}}_renderSegment(t,e,i,n,s){let r;const h=this._regioncode(t,e),l=this._regioncode(i,n);0===h&&0===l?(s.moveTo(t,e),s.lineTo(i,n)):(r=this._clipSegment(t,e,i,n,h,l))&&(s.moveTo(r[0],r[1]),s.lineTo(r[2],r[3]))}contains(t,e,i){return(e=+e)==e&&(i=+i)==i&&this._step(t,e,i)===t}find(t,e,i=0){if((t=+t)!=t||(e=+e)!=e)return-1;let n;for(;(n=this._step(i,t,e))>=0&&n!==i;)i=n;return n}_step(t,e,i){const{delaunay:{points:n,triangles:s},edges:r,index:h}=this;if(0===n.length)return-1;const l=h[2*t],o=h[2*t+1];if(l===o)return-1;let a=t,c=3*r[l],u=(e-n[2*a])**2+(i-n[2*a+1])**2;switch(t){case s[c]:c=s[c+2];break;case s[c+1]:c=s[c];break;case s[c+2]:c=s[c+1]}let f=(e-n[2*c])**2+(i-n[2*c+1])**2;f<u&&(u=f,a=c);for(let h=l;h<o;++h){switch(c=3*r[h],t){case s[c]:c=s[c+1];break;case s[c+1]:c=s[c+2];break;case s[c+2]:c=s[c]}(f=(e-n[2*c])**2+(i-n[2*c+1])**2)<u&&(u=f,a=c)}return a}_cell(t){const{index:e,edges:i,circumcenters:n}=this,s=e[2*t],r=e[2*t+1];if(s===r)return null;const h=new Float64Array(2*(r-s));for(let t=s,e=0;t<r;++t,e+=2){const s=2*i[t];h[e]=n[s],h[e+1]=n[s+1]}return h}_clip(t){const e=this._cell(t);if(null===e)return null;const{vectors:i}=this,n=4*t;return i[n]||i[n+1]?this._clipInfinite(t,e,i[n],i[n+1],i[n+2],i[n+3]):this._clipFinite(t,e)}_clipFinite(t,e){const i=e.length;let n,s,r,h,l,o=null,a=e[i-2],c=e[i-1],u=this._regioncode(a,c);for(let t=0;t<i;t+=2)if(n=a,s=c,a=e[t],c=e[t+1],r=u,u=this._regioncode(a,c),0===r&&0===u)h=l,l=0,o?o.push(a,c):o=[a,c];else{let e,i,f,x,_;if(0===r){if(null===(e=this._clipSegment(n,s,a,c,r,u)))continue;[i,f,x,_]=e}else{if(null===(e=this._clipSegment(a,c,n,s,u,r)))continue;[x,_,i,f]=e,h=l,l=this._edgecode(i,f),h&&l&&this._edge(t,h,l,o,o.length),o?o.push(i,f):o=[i,f]}h=l,l=this._edgecode(x,_),h&&l&&this._edge(t,h,l,o,o.length),o?o.push(x,_):o=[x,_]}if(o)h=l,l=this._edgecode(o[0],o[1]),h&&l&&this._edge(t,h,l,o,o.length);else if(this.contains(t,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2))return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];return o}_clipSegment(t,e,i,n,s,r){for(;;){if(0===s&&0===r)return[t,e,i,n];if(s&r)return null;let h,l,o=s||r;8&o?(h=t+(i-t)*(this.ymax-e)/(n-e),l=this.ymax):4&o?(h=t+(i-t)*(this.ymin-e)/(n-e),l=this.ymin):2&o?(l=e+(n-e)*(this.xmax-t)/(i-t),h=this.xmax):(l=e+(n-e)*(this.xmin-t)/(i-t),h=this.xmin),s?(t=h,e=l,s=this._regioncode(t,e)):(i=h,n=l,r=this._regioncode(i,n))}}_clipInfinite(t,e,i,n,s,r){let h,l=Array.from(e);if((h=this._project(l[0],l[1],i,n))&&l.unshift(h[0],h[1]),(h=this._project(l[l.length-2],l[l.length-1],s,r))&&l.push(h[0],h[1]),l=this._clipFinite(t,l))for(let e,i=0,n=l.length,s=this._edgecode(l[n-2],l[n-1]);i<n;i+=2)e=s,s=this._edgecode(l[i],l[i+1]),e&&s&&(i=this._edge(t,e,s,l,i),n=l.length);else this.contains(t,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2)&&(l=[this.xmin,this.ymin,this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax]);return l}_edge(t,e,i,n,s){for(;e!==i;){let i,r;switch(e){case 5:e=4;continue;case 4:e=6,i=this.xmax,r=this.ymin;break;case 6:e=2;continue;case 2:e=10,i=this.xmax,r=this.ymax;break;case 10:e=8;continue;case 8:e=9,i=this.xmin,r=this.ymax;break;case 9:e=1;continue;case 1:e=5,i=this.xmin,r=this.ymin}this.contains(t,i,r)&&(n.splice(s,0,i,r),s+=2)}return s}_project(t,e,i,n){let s,r,h,l=1/0;if(n<0){if(e<=this.ymin)return null;(s=(this.ymin-e)/n)<l&&(h=this.ymin,r=t+(l=s)*i)}else if(n>0){if(e>=this.ymax)return null;(s=(this.ymax-e)/n)<l&&(h=this.ymax,r=t+(l=s)*i)}if(i>0){if(t>=this.xmax)return null;(s=(this.xmax-t)/i)<l&&(r=this.xmax,h=e+(l=s)*n)}else if(i<0){if(t<=this.xmin)return null;(s=(this.xmin-t)/i)<l&&(r=this.xmin,h=e+(l=s)*n)}return[r,h]}_edgecode(t,e){return(t===this.xmin?1:t===this.xmax?2:0)|(e===this.ymin?4:e===this.ymax?8:0)}_regioncode(t,e){return(t<this.xmin?1:t>this.xmax?2:0)|(e<this.ymin?4:e>this.ymax?8:0)}}const x=2*Math.PI;class _{constructor(t){const{halfedges:i,hull:n,triangles:s}=new e(t);this.points=t,this.halfedges=i,this.hull=Uint32Array.from(function*(t){let e=t;do{yield e.t}while((e=e.next)!==t)}(n)),this.triangles=s}voronoi(t){return new f(this,t)}render(t){const e=null==t?t=new u:void 0,{points:i,halfedges:n,triangles:s}=this;for(let e=0,r=n.length;e<r;++e){const r=n[e];if(r<e)continue;const h=2*s[e],l=2*s[r];t.moveTo(i[h],i[h+1]),t.lineTo(i[l],i[l+1])}return this.renderHull(t),e&&e.value()}renderPoints(t,e=2){const i=null==t?t=new u:void 0,{points:n}=this;for(let i=0,s=n.length;i<s;i+=2){const s=n[i],r=n[i+1];t.moveTo(s+e,r),t.arc(s,r,e,0,x)}return i&&i.value()}renderHull(t){const e=null==t?t=new u:void 0,{points:i,hull:n,triangles:s}=this,r=n.length;let h,l=2*s[n[r-1]];for(let e=0;e<r;++e)h=l,l=2*s[n[e]],t.moveTo(i[h],i[h+1]),t.lineTo(i[l],i[l+1]);return e&&e.value()}renderTriangle(t,e){const i=null==e?e=new u:void 0,{points:n,triangles:s}=this,r=2*s[t*=3],h=2*s[t+1],l=2*s[t+2];return e.moveTo(n[r],n[r+1]),e.lineTo(n[h],n[h+1]),e.lineTo(n[l],n[l+1]),e.closePath(),i&&i.value()}}_.from=function(t,e=function(t){return t[0]},i=function(t){return t[1]},n){return new _("length"in t?function(t,e,i,n){const s=t.length,r=new Float64Array(2*s);for(let h=0;h<s;++h){const s=t[h];r[2*h]=e.call(n,s,h,t),r[2*h+1]=i.call(n,s,h,t)}return r}(t,e,i,n):Float64Array.from(function*(t,e,i,n){let s=0;for(const r of t)yield e.call(n,r,s,t),yield i.call(n,r,s,t),++s}(t,e,i,n)))},t.Delaunay=_,t.Voronoi=f,Object.defineProperty(t,"__esModule",{value:!0})});
